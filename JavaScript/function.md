# 함수

> ### 함수란?
>
> 일련의 과정을 문 <sup>statement</sup> 으로 구현하고 코드 블록으로 감싸 하나의 실행 단위로 정의한 것입니다.

---

## 함수 정의 방식

| 함수 정의 방식       | 예시                                              |
| -------------------- | ------------------------------------------------- |
| 함수 선언문          | `function add(x, y) {return x + y}`               |
| 함수 표현식          | `var add = function(x, y) {return x + y}`         |
| Function 생성자 함수 | `var add = new Function('x', 'y', 'return x + y'` |
| 화살표 함수(ES6)     | `var add = (x, y) => x + y`                       |

---

## 함수 선언문

### **함수 선언문**

```javascript
function add(x, y) {
  return x + y;
}
```

### **함수 선언문은 함수 이름을 생략할 수 없습니다.**

```javascript
  function (x ,y) {
    return x + y;
  }
  // SyntaxError가 발생합니다.
```

### **함수 선언문은 표현식이 아닌 문입니다.**

표현식이 아닌 문은 변수에 할당할 수 없습니다. 함수 선언문도 표현식이 아닌 문이므로 변수에 할당할 수 없습니다. 하지만 아래 코드는 에러를 발생시키지 않습니다.

```javascript
var add = function add(x, y) {
  return x + y;
};
```

자바스크립트 엔진은 코드 문맥에 따라 함수 선언문을 함수 리터럴로 해석합니다.

> ### 함수 리터럴이란?
>
> 리터럴은 사람이 이해할 수 있는 문자 또는 약속된 기호를 사용해 값을 생성하는 표기 방식입니다. 자바스크립트 함수는 객체 타입의 값입니다. 따라서 숫자 값을 숫자 리터럴로 생성하고, 객체를 객체 리터럴로 생성하는 것처럼 함수도 함수 리터럴로 생성할 수 있습니다.
> 형태는 함수 선언문과 같습니다.

예를 들어, {}의 경우에도 문맥에 따라 블록문일 수도 있고 객체 리터럴일 수도 있다는 점입니다.

```javascript
{
} // 단독으로 존재하는 {}는 블록문으로 해석합니다.
var foo = {}; // 하지만 값으로 평가되어야 할 문맥에선 {}을 객체 리터럴로 해석합니다.
```

```javascript
// 아래 함수는 식별자 add의 값으로,
//  함수 리터럴로 평가되어야 할 문맥입니다.
var add = function add(x, y) {
  return x + y;
};
```

```javascript
// 자바스크립트는 함수 선언문으로 정의된 함수를 참조할 수 있는
// 함수 이름과 똑같은 식별자를 암묵적으로 생성합니다.
function foo() {
  console.log('foo');
}
// 같은 의미입니다.
var foo = function foo() {
  console.log('foo');
};

foo(); // foo
```

---

## 함수 표현식

자바스크립트의 함수는 값처럼 변수에 할당할 수도 있고 프로퍼티 값이 될 수도 있으며 배열의 요소가 될 수도 있습니다. 이처럼 값의 성질을 갖는 객체를 **일급 객체**라고 합니다.
**자바스크립트의 함수는 일급 객체**입니다.

### 함수 리터럴에서 함수 이름은 생략할 수 있습니다.

```javascript
var add = function (x, y) {
  return x + y;
};
```

### 함수를 호출할 때는 함수 이름이 아니라 함수를 가리키는 식별자를 호출합니다.

```javascript
var add = function foo(x, y) {
  return x + y;
};

add(3, 5); // 8
foo(3, 5); // ReferenceError 발생.
```

함수 이름은 함수 몸체 내부에서만 유효한 식별자 입니다.

### 함수 생성 시점과 함수 호이스팅

함수 선언문으로 함수를 정의하면 런타임 이전에 함수 객체가 먼저 생성됩니다. 따라서 함수 선언문 이전에 함수를 참조할 수 있으며 호출할 수도 있습니다. 이처럼 함수 선언문이 코드의 선두로 끌어 올려진 것처럼 동작하는 자바스크립트 고유의 특징을 **함수 호이스팅** 이라고 합니다.

```javascript
console.log(foo); // 함수foo
console.log(bar); // undefined

foo(); // foo
bar(); // TypeError: bar는 함수가 아닙니다.

function foo() {
  console.log('foo');
}
var bar = function () {
  console.log('bar');
};
```

함수 호이스팅은 함수를 호출하기 전에 반드시 함수를 선언해야 한다는 규칙을 무시합니다. 함수 선언문 대신 함수 표현식을 사용할 것을 권장하기도 합니다.

---

## Function 생성자 함수

Function 생성자 함수에 매개변수 목록과 함수 몸체를 문자열로 전달하면서 new 연산자와 함께 호출하면 함수 객체를 생성해서 반환합니다.

```javascript
var add = new Function('x', 'y', 'return x + y');
console.log(add(3, 5)); // 8
```

---

## 화살표 함수

ES6에서 도입된 화살표 함수는 function 키워드 대신 화살표를 사용해 좀 더 간략한 방법으로 함수를 선언할 수 있습니다.

```javascript
const add = (x, y) => x + y;
console.log(add(3, 5)); // 8
```

화살표 함수는 기존의 함수보다 표현과 내부 동작을 간략화합니다.
**화살표 함수는 생성자 함수로 사용할 수 없으며, 기존 함수와 this 바인딩 방식이 다르고, prototype 프로퍼티가 없으며 arguments 객체를 생성하지 않습니다.**
