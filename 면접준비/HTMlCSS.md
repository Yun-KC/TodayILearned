## HTML, CSS 질문

- **HTML에서 id와 class의 차이가 무엇인가요?**
  id와 class는 html의 요소의 속성으로 CSS, Javascript에서 요소를 특정할 때 사용합니다.
  id는 한 요소에 한 아이디만 적용가능하고 다은 요소에 중복 사용할 수 없습니다.
  class는 여러 요소에 여러개의 클래스를 지정할 수 있고 다른 요소에 중복 사용이 가능합니다.
- **HTML에서 script태그의 위치와 위치에 따라 고려해야 하는 점은 무엇인가요 ?**
  브라우저는 HTML를 파싱하여 DOM을 생성해 나가며 도중에 script 태그를 만나면 src 어트리뷰트에 정의된 자바스크립트 파일을 서버에 요청합니다.
  로드한 자바스크립트 코드를 파싱하기 위해 자바스크립트 엔진에 제어권을 넘기고 자바스크립트 파싱과 실행이 종료되면 렌더링 엔진으로 다시 제어권을 넘겨 HTML 파싱이 중단된 지점부터 다시 시작하여 DOM 생성을 재개합니다.
  자바스크립트는 DOM API를 통해 HTMl 요소를 제어합니다.
  최소한 제어하고 싶은 요소가 선언된 곳 아래부터 script 태그가 위치해야합니다.
- **Reflow가 발생하는 이유와 방지 방법이 무엇인가요?**
  리플로우가 발생하는 이유는 자바스크립트 코드에 DOM이나 CSSOM을 변경하는 **DOM API사용으로 레이 아웃이 변경된 경우에 리플로우가 발생**합니다.
  레이 아웃을 다시 계산하고 브라우저 화면에 렌더링하는 과정은 많은 비용을 발생시킵니다.
  이를 방지하려면 불필요한 DOM 심도를 줄이고, CSS 규칙을 최소화, 애니메이션과 같이 복잡한 렌더링 변경이 필요한 경우 흐름 밖에서 변경합니다.
  변경할 때는 절대 위치나 고정 위치를 사용합니다.
  (절대 위치, 고정위치는 css: position의 fixed나 absolute를 말하는 걸까?)
- **이벤트 버블링이란 무엇인가요?**
  DOM 트리 상에 존재하는 DOM 요소 노드에서 발생한 이벤트는 DOM 트리를 통해 전파됩니다. 이를 이벤트 전파라고 합니다.
  이벤트가 전파될때는 이벤트 객체가 이벤트를 발생시킨 DOM 요소인 이벤트 타깃을 중심으로 DOM 트리를 통해 전파됩니다.
  여기서 이벤트가 상위 요소에서 하위 요소 방향으로 전파되는 것을 **캡처링 단계**이고,
  이벤트가 이벤트 타깃에 도달하면 **타깃 단계**,
  이벤트 타깃에서 다시 상위 요소 방향으로 전파되는 것을 **버블링 단계**라고 합니다.
  이벤트 전파는 이벤트 객체의 stopPropagation 메서드를 통해 중지시킬 수 있습니다.
- **번들링이 무엇인가요?**
  웹펙 번들러란 웹 애플리케이션을 구성하는 여러 리소스들을 하나또는 하나의 파일로 병합 및 압축 해주는 동작을 모듈 번들링이라고 합니다.
  각각의 파일에서 동일한 명칭의 변수를 사용할 때 발생하는 충돌 문제도 해결하고,
  JS 파일은 하나의 JS 파일로,
  CSS 파일도 하나의 CSS 파일로 만들어 줌으로써
  여러개의 파일을 로드해야 하는 번거러움도 사라지는 장점이 있습니다.
- **서버 사이드 렌더링과 클라이언트 사이드 렌더링의 차이점이 무엇인가요?**
  서버 사이드 렌더링(ssr)은 웹페이지를 서버에서 렌더링하여 클라이언트에 보내는 방식이고,
  클라이언트 사이드 렌더링(csr)은 웹페이지를 클라이언트에서 렌더링하는 방식입니다.
  ssr은 초기 로딩속도가 빨라 사용자가 콘텐츠를 빨리 볼 수 있고 검색엔진 최적화 등에 장점이 있습니다.
  하지만 ssr은 페이지 전환시 깜빡임과 서버 렌더링에 따른 부하가 발생합니다.
  csr은 사용자의 행동에 따른 필요한 부분만 다시 읽어들이기 때문에 서버 측에서 렌더링하여 전체 페이지를 다시 읽어들이는 것보다 빠른 인터렉션을 기대할 수 있습니다.
  하지만 초기 로딩속도가 느리고 검색엔진 최적화가 어렵습니다.
- **브라우저의 렌더링 과정을 설명해주세요**
  1. 브라우저는 html, css, 자바스크립트, 이미지 파일등 렌더링에 필요한 리소스들을 서버에 요청하고 응답받습니다.
  2. 브라우저의 렌더링 엔진은 서버로부터 응답받은 html, css를 파싱하여 **DOM**과 **CSSOM**을 생성하고 이 둘을 결합하여 **렌더트리(render tree)**를 생성합니다.
  3. 브라우저의 자바스크립트 엔진은 서버로부터 응답받은 자바스크립트를 파싱하여 **ast(abstract syntax tree)**를 생성하고 바이트 코드로 변환하여 실행합니다.
     만약 이때 자바스크립트가 dom api를 통해 dom이나 cssom을 변경한다면 **리플로우** 과정을 거쳐 다시 렌더트리로 결합됩니다.
  4. 결합된 렌더트리를 기반으로 html요소의 레이아웃을 계산하고 브라우저에 html요소를 페인팅합니다.
- **브라우저 동작 과정에 대해서 설명해주세요.**
  브라우저는 사용자가 참조하고자 하는 웹페이지를 서버에 요청하고 서버의 응답을 받아 브라우저에 표시하는 것입니다.
  브라우저는 서버로부터 HTML, CSS, Javascript, 이미지 파일 등을 응답받습니다.
  HTML,CSS 파일은 렌더링 엔진의 HTML 파서와 CSS 파서에 의해 파싱되어 DOM, CSSOM 트리로 변환합니다.
  HTML 파일을 파싱하는 중에 script 태그를 만나면 Javscript을 로드하고 파싱하여 실행하고
  렌더 트리로 결합됩니다. 이렇게 생성된 렌더 트리를 기반으로 브라우저는 웹페이지를 표시합니다.
- **lazy loading 이란?**
  lazy loding은 페이지 내에서 즉시 필요하지 않은 리소스들의 로딩 시점을 뒤로 미루는 것입니다.
  페이지에서 이미지는 사용자에게 보여지는 시점이 올 때 로딩이 됩니다.
  lazy loding을 사용하면 페이지 초기 로딩 시 필요한 리소스들만 보내어 통신 비용을 절약할 수 있습니다.
- **AJAX가 무엇인가요?**
  자바스크립트를 사용하여 브라우저가 서버에게 비동기 방식으로 데이터를 요청하고, 응답받은 데이터로 웹페이지는 동적으로 갱신하는 프로그래밍 방식입니다.
- **HTML CSS의 관계를 설명해주세요.**
  HTML은 웹 브라우저를 통해 사용자에게 보이는 웹 문서를 작성하기 위한 마크업 언어로 **웹 문서의 내용과 구조를 담당하는 언어**입니다.
  CSS는 HTML같은 구조화 된 문서를 **화면에 어떻게 렌더링할 것인지를 정의하는 언어**입니다.
- **CSS보다 SASS가 가진 장점이 무엇이 있나요?**
  SASS(Syntactically Awesome StyleSheets)는 CSS pre-processor(전처리기 - 컴파일되어 CSS 문법으로 변환)로서 **CSS의 한계와 단점을 보완하여 보다 가독성이 높고 코드의 재사용에 유리한 CSS를 생성하기 위한 CSS의 확장**입니다.
  CSS의 간결한 문법은 배우기 쉬우며 명확하여 프로젝트 초기에는 문제가 없지만, 규모가 커지고 수정이 빈번히 발생함에 따라 쉽게 가독성이 떨어지고 유지보수에 어려워지는 단점이 있습니다.
  SASS는 CSS를 구조화 하여 표현하고, 유지보수의 편의성을 큰 폭으로 향상시킬 수 있습니다.
- **Styled-Component가 무엇인가요?**
  Styled-Component는 자바스크립트 안에 스타일을 선언합니다.
  장점으론 자유로운 CSS 커스텀 컴포넌트를 만들 수 있고,
  해당 컴포넌트에 대해서의 스타일만을 정의하므로,
  스타일 적용범위가 한정적이라서 사이드 이펙트 확률이 줄어들고,
  컴포넌트의 단위 테스트가 가능합니다.
  단점으론 인터랙션한 페이지일 경우 CSS 파일을 따로 관리하는 방법에 비해 느린 성능을 보여줄 수 있습니다.
- **CSS box model이 무엇인가요?**
  모든 HTMl 요소는 박스 모양으로 구성됩니다. 이것을 박스 모델이라고 합니다.
  박스 모델은 margin, border, padding, content 순으로 구성되며 박스는 실제 화면에서 차지하는 크기를 결정하는 요인이 됩니다.
  border는 테두리,
  margin은 border를 기준으로 밖의 여백이고,
  padding은 안의 여백을 말합니다.
  content는 요소의 콘텐츠가 표시되는 영역입니다.
- **CSS 에서em, px, rem이 각각 무엇인가요?**
  px는 모니터마다 고정 값으로 정해지는 기본적인 단위입니다
  em은 현재 요소의 폰트사이즈를 기준으로 배율을 지정합니다.
  rem은 HTMl 요소의 폰트사이즈를 기준으로 배율을 지정합니다.
- **CSS의 position 속성이 무엇인가요?**
  **position 속성은 html 문서 상에서 요소가 배치되는 방식을 결정합니다.**
  static - 기본값입니다. html문서 상에서 원래 있어야 하는 위치에 배치됩니다.
  relative - 원래 위치를 기준으로 top, bottom, left, right의 속성에 따라 배치됩니다.
  absolute - 요소의 배치 기준을 상위 요소에서 찾아 사용합니다.
  DOM트리를 따라 올라가 position 속성이 static이 아닌 첫 번째 상위 요소가 해당 요소의 배치 기준으로 설정됩니다. 만약 해당 상위 요소에 static이 아닌 요소가 없다면 body 요소가 배치 기준이 됩니다.
- **inline과 block 이 무엇인가요?**
  inline은 태그 안의 글자 길이 만큼의 영역만 화면에 표시합니다. width와 height 값을 조정할 수 없습니다.
  block은 inline과 달리 새로운 줄로 시작하며 해당 줄의 가로를 전부 차지합니다.
